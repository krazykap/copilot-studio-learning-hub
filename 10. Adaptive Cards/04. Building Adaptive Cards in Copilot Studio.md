# 04. Building Adaptive Cards in Copilot Studio

## 4.1 From Idea to Working Card

Building an Adaptive Card in Copilot Studio usually follows this sequence: define the user task, sketch the layout, build the card (visually or in JSON), connect it to variables and actions, then test and refine. Treat the card as a small, self‑contained interaction unit with a clear beginning (context), middle (inputs or choices), and end (actions and outcome).

Before opening Copilot Studio, clarify:
- What question or task the card is handling.
- What minimum data you must show.
- What data you must collect.
- Where the data will go next (variables, flows, external systems).

Clear intent keeps the card focused and prevents it from becoming an over‑complicated form.

## 4.2 Choosing a Starting Point: Designer, JSON, or Gallery

There are three common ways to start building cards for a Copilot Studio topic.

- **Visual designer inside Copilot Studio**: Best for most makers. You drag elements onto a canvas and configure properties in side panels while the platform maintains the underlying JSON and output variables.
- **Pasting JSON from the Adaptive Cards designer or samples**: Best when you have an existing card definition or you are comfortable editing JSON. You paste the card payload into the node and then adapt it.
- **Using templates from an Adaptive Cards gallery**: Microsoft and community galleries provide ready‑to‑use templates (approvals, quick forms, summaries) with both layout and sample data.

For complex projects, many teams iterate in the external Adaptive Cards designer and sample gallery, then paste the JSON into Copilot Studio and connect it to variables and Power Fx.

## 4.3 Building a Card with the “Ask with Adaptive Card” Node

### 4.3.1 Adding the Node

Within a topic, you add an Adaptive Card via the interactive card node.

Typical steps:
- Insert a node at the point where you want to display a card in the topic canvas.
- Choose the **Ask with Adaptive Card** option.
- Open the card editor from the node’s properties.

Copilot Studio associates this node with its own input/output schema so it can bind card fields to variables automatically.

### 4.3.2 Using the Visual Designer Mode

In visual mode, you:
- Drag elements such as TextBlock, Container, Input.Text, Input.ChoiceSet, Input.Date, and buttons onto the canvas.
- Configure element properties (label, placeholder, required, default value, etc.) through property panels instead of editing JSON directly.
- Add action buttons (usually Action.Submit) as submit controls for the card.

When you save, Copilot Studio analyzes the inputs and automatically defines corresponding output variables for the node, using the input `id` values as variable keys.

### 4.3.3 Editing in JSON Mode

If you switch to JSON mode, you can see and modify the full card payload.

Typical uses:
- Pasting a complete card definition from the Adaptive Cards sample gallery.
- Adding advanced properties not exposed yet in the visual UI.
- Fine‑tuning layout details like spacing, style, or version‑specific features.

A good practice is to get the basic structure working in visual mode first, then switch to JSON only for fine‑grained control.

## 4.4 Working with Variables and Outputs

### 4.4.1 How Outputs Are Created

Every input element in the card (text, choice, toggle, date, number) has an `id` property. In Copilot Studio, that `id` becomes the key for an output variable when the card is submitted. For example, an input with `id` `customerEmail` produces an output variable like `AdaptiveCardNodeName.customerEmail` that can be reused in later nodes.

Key practices:
- Choose `id` values that are meaningful, unique in the card, and consistent with your topic naming patterns.
- Avoid changing `id`s after the card is in use, because downstream nodes may rely on those variable names.

### 4.4.2 Inspecting and Adjusting the Schema

Copilot Studio usually infers the output schema automatically, but you can review it:
- In the node’s properties, there is a schema or outputs section where you see each output and its type.
- In some versions, you can rename or map outputs to keep variable names consistent across topics.

This is especially important if the card drives integrations such as Power Automate flows or if multiple topics share a common card pattern.

### 4.4.3 Using Card Outputs in the Topic

Once the card runs and the user clicks Submit, subsequent nodes can:
- Insert variable values in messages (for example, greeting the user by the name collected).
- Use values in condition nodes (for example, branching based on a priority field).
- Pass values into actions such as Power Automate flows or Dataverse operations.

Thinking of the card as a structured input step in the flow helps you design its outputs deliberately.

## 4.5 Adding Dynamic Content with Power Fx

### 4.5.1 Switching to Formula Mode

Copilot Studio provides a Formula mode on the card node that converts the JSON into a Power Fx expression. In this mode you can:
- Embed variables (topic, agent, or context variables) directly into card text and properties.
- Control visibility or values of elements based on conditions.
- Compose strings or simple expressions at runtime.

When you switch from JSON to Formula, the editor wraps the JSON as a Power Fx literal so you can start replacing static text with expressions.

### 4.5.2 Typical Power Fx Bindings

Common patterns include:
- Injecting user names, IDs, or contextual data into TextBlocks or labels.
- Pre‑filling Input.Text values with known data (for example, the user’s email or last known value).
- Dynamically composing titles or descriptions based on prior steps in the topic.

These expressions keep cards in sync with the conversation context and remove repetitive typing for users.

### 4.5.3 Limits of Formula Mode

Not every aspect of the Adaptive Card schema is editable via Formula mode. In current implementations:
- Formula expressions are typically used for text, labels, visibility, and similar properties.
- Certain collection properties (for example, building ChoiceSet choices from complex data) may require staying in JSON mode or using other patterns.

When you need fully dynamic templating, consider using JSON templating patterns combined with upstream logic, or precomputing arrays in the topic or flow and then binding to them where supported.

## 4.6 Building Smart, Conditional Cards

### 4.6.1 Visibility Based on Variables

A powerful pattern in Copilot Studio is using a variable to show or hide card elements. Examples include:
- Showing a “Manager comments” input only when an `isManager` flag is true.
- Showing additional fields when a user selects a certain request type in an earlier topic step.

This usually involves:
- Storing a decision in a topic variable.
- Binding that variable to the card element’s visibility via Power Fx in Formula mode, where supported.

### 4.6.2 Beware of Same‑Card Dependencies

Directly toggling visibility based on another input in the same card is limited. Many host implementations expect visibility to be driven by variables whose values are set before the card renders, not by live changes to other inputs in that same card. If you need richer wizard‑style flows, consider:
- Splitting the interaction into multiple cards in sequence.
- Using Action.ToggleVisibility for user‑initiated show or hide behavior tied to buttons.

### 4.6.3 Scenario‑Specific Show/Hide

Good use cases for conditional visibility include:
- Advanced options sections that most users do not need.
- Extra detail blocks shown only for certain priority levels or request types.
- Compliance acknowledgement text shown only in specific geographies or roles.

Design these conditions alongside your topic logic so the card appears tailored without becoming overcomplicated.

## 4.7 Reusing and Templating Cards

### 4.7.1 Reusing JSON Across Topics

If multiple topics need similar forms (for example, “basic contact form,” “short approval”), treat the card JSON as a template.

Practical steps:
- Maintain a card library document or internal topic where canonical JSON definitions are stored.
- Copy and adapt these into new Adaptive Card nodes as needed.
- Keep `id` patterns and layout consistent so outputs behave predictably across topics.

### 4.7.2 Using Adaptive Cards Gallery Resources

Microsoft’s Adaptive Cards gallery and Copilot Studio guidance provide complete card templates with sample data and usage patterns. For Copilot Studio specifically, gallery samples can:
- Show how to wire cards to back‑end actions.
- Provide best‑practice layouts for approvals, updates, notifications, and lists.

Studying and adapting these samples is often faster and safer than designing every card from scratch.

### 4.7.3 Separating Layout from Data

Adaptive Cards support a templating concept where layout (card JSON) is separated from data payloads. Even though Copilot Studio abstracts some of this, you can still apply the idea:
- Keep the card structure stable.
- Feed different data into the same structure via variables or Power Fx expressions.
- Avoid hardcoding literal business values in the layout when they might change frequently.

This approach makes maintenance easier and reduces the chance of inconsistent UX across flows.

## 4.8 Integrating Cards with Power Automate and External Systems

### 4.8.1 Using Card Outputs in Flows

A common pattern is to:
- Collect data in the Adaptive Card node.
- Pass the resulting variables into a Power Automate flow for processing.

Examples:
- Creating a record in Dataverse or SharePoint based on card input.
- Sending an email or Teams message summarizing the card submission.
- Calling external APIs to submit requests into line‑of‑business systems.

The key is to keep field names, types, and required or optional status aligned between the card, the topic, and the flow.

### 4.8.2 Round‑Trip Scenarios

In some designs, a flow fetches data and then a subsequent Adaptive Card presents that data back to the user for confirmation or editing. Patterns include:
- Flow retrieves account details → topic stores them → card shows them for confirmation.
- Flow retrieves options (for example, locations or products) → topic stores them in variables → card presents them as choices, where supported.

Careful mapping between flow outputs and card inputs ensures data stays in sync.

## 4.9 Building Lists, Carousels, and Multi‑Item Cards

### 4.9.1 Lists Inside a Single Card

For short lists, you can use:
- FactSet elements to show label/value pairs for several items.
- Repeated TextBlocks or ColumnSets representing list rows.

This is useful for compact summaries such as top results, open tickets, or key metrics.

### 4.9.2 Carousels and Multiple Cards

When you have multiple items that are too large for a single card, Copilot Studio supports card carousels in specific patterns. In this design:
- Each item is rendered as a separate Adaptive Card.
- The client displays them in a horizontal carousel so users can swipe or scroll through them.

This works well for search results, catalog browsing, or scenario selection where each card represents one choice.

### 4.9.3 Performance Considerations

When building multi‑item cards:
- Avoid sending very large payloads; consider limiting to a top subset or paging.
- Truncate descriptions or use links instead of long text to keep cards small and fast to render.
- Test in target channels to ensure scrolling and interaction feel responsive.

## 4.10 Practical Build‑Time Checklist

When declaring a card build‑complete in Copilot Studio, run through a quick checklist:

- **Structure**
  - Does the card have a clear header, concise body, and 1–3 actions?
  - Are inputs grouped and ordered logically?

- **Variables**
  - Are input `id`s meaningful and unique?
  - Are all required values used downstream (conditions, messages, flows)?

- **Dynamic Behavior**
  - Are Power Fx expressions used where dynamic text or visibility is needed (and only where supported)?
  - Are conditional elements tied to well‑defined topic variables?

- **Reusability**
  - Is the card JSON or design documented or stored for reuse?
  - Could other topics benefit from a similar card structure?

- **Integration**
  - If a flow or external system is involved, do field names and types align?
  - Are errors or edge cases (missing data, invalid input) handled gracefully in the topic?

By applying this checklist and the patterns in this chapter, you can move from simple, static Adaptive Cards to robust, dynamic, and reusable cards that power sophisticated Copilot Studio experiences.

## Conclusion
Building Adaptive Cards in Copilot Studio is a powerful way to create interactive, user‑friendly experiences. By following best practices around design, variable management, dynamic content, and integration, you can craft cards that not only look good but also function seamlessly within your topics. As you gain experience, you’ll find opportunities to reuse and adapt card designs, making your development process more efficient and your user interactions more engaging.