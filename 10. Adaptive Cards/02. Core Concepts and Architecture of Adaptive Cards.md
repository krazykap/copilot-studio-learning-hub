# 02. Core Concepts and Architecture of Adaptive Cards

## The Adaptive Card Schema
An Adaptive Card is fundamentally a JSON-serialized card object model. JSON (JavaScript Object Notation) is a lightweight, text-based format for structuring and exchanging data—it is human-readable, easy to parse, and universally supported across platforms and programming languages. By using JSON as the authoring format, Adaptive Cards remain platform-agnostic, allowing the same card definition to be deployed across different host applications without modification.

### Root-Level Card Structure
Every Adaptive Card begins with a root AdaptiveCard object that defines the card's overall configuration. The basic structure follows this pattern:
<pre>
{
  "$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
  "type": "AdaptiveCard",
  "version": "1.5",
  "body": [ ... ],
  "actions": [ ... ]
}
</pre>
Each of these properties serves a specific purpose:
- **$schema**: A reference URI pointing to the JSON schema that validates the card's structure. This helps tools (like the Adaptive Card Designer) understand which properties are allowed and how they should be formatted. The schema URL typically points to `adaptivecards.io/schemas/adaptive-card.json`.
- **type**: This property indicates that the object is an AdaptiveCard. Must always be `"AdaptiveCard"` for the root element, indicating this is an Adaptive Card (as opposed to other JSON structures).
- **version**: Specifies the Adaptive Card schema version (e.g., 1.0, 1.2, 1.5). The version determines which features and elements are available. Host applications only support certain versions; using a newer version than the host supports may result in rendering errors or missing features. When deploying cards to Copilot Studio, it is important to check which versions are supported by the target channels (Teams, web, Outlook) to ensure compatibility.
- **body**: An array containing the card's primary content—the elements (TextBlocks, Images, Inputs, Containers, etc.) that make up the visual and interactive portion of the card. All elements in the body stack vertically and expand to the width of their parent container by default (similar to `display: block` in HTML).
- **actions**: An array of action definitions (typically buttons) that appear in an action bar at the bottom of the card. Common action types include Action.Submit (submit form data), `Action.OpenUrl` (open a URL), `Action.ShowCard` (show a nested card), and others.

### Metadata and Display Properties
Beyond the essential properties above, Adaptive Cards support additional metadata properties that control overall presentation and behavior:
- **backgroundImage**: Allows setting a background image for the entire card, enhancing visual appeal.
- **speak**: Defines text for text-to-speech rendering, enabling accessibility for users who rely on screen readers or voice-based interaction.
- **lang**: Specifies the language of the card's content (e.g., `"en-US"`, `"fr-FR"`), assisting with localization and text-to-speech rendering.
- **rtl**: A boolean property indicating right-to-left text direction, essential for languages like Arabic and Hebrew.

## Core Element Types
### 1. Text and Display Elements
A. **TextBlock:** The most fundamental element, TextBlock displays a block of styled text. TextBlock properties include:
	- **`text`**: The actual text content to display.
	- **`size`**: Controls the font size (e.g., Small, Medium, Large).
	- **`weight`**: Controls the font weight (e.g., Lighter, Default, Bolder).
	- **`color`**: Sets the text color (e.g., Default, Dark, Light, Accent).
	- **`wrap`**: A boolean indicating whether the text should wrap to multiple lines if it exceeds the width of the card.
	- **`maxLines`**: Limits the number of lines displayed; excess text is truncated with an ellipsis.
	- **`style`**: Defines the text style (e.g., `"default"`, `"heading"`).

	TextBlock is essential for creating readable, well-structured card content with clear visual hierarchy.

B. **Image:** Displays an image with properties to control sizing, aspect ratio, and alignment. The `url` property specifies the image source (supports both https URLs and data URIs), and properties like `size`, `style` (avatar, person, or article), and `selectAction` allow interactive image handling.

C. **RichTextBlock:** An enhanced text element (available in version 1.2 and later) that supports inline formatting such as bold, italic, and links within a single text block. This enables richer typographic control than plain TextBlock elements.

### 2. Container and Layout Elements
Container elements organize and arrange other elements, providing structure and layout control:
A. **Container**: A basic container that groups a collection of child elements. Containers help organize content into logical sections and support properties like background color, padding, and styling.
B. **ColumnSet and Column**: Enable side-by-side column layouts. A ColumnSet contains one or more Column elements; each column is a container with a specified width (either absolute pixels or relative weight). This is essential for creating multi-column layouts (e.g., two-column forms, side-by-side images and text).
C. **FactSet**: A specialized container for displaying a list of label-value pairs (facts). This is ideal for summaries or data displays where information is organized as key-value pairs.
D. **ImageSet**: A container for displaying multiple images as a gallery, with the host application determining how to render them (grid, carousel, etc.).
E. **Table (version 1.5+)**: A structured grid element for displaying tabular data with rows, columns, and header support. Tables are useful for displaying structured datasets in a compact, scannable format.

### 3. Input Elements
Input elements allow cards to collect user data, transforming Adaptive Cards from display-only to interactive forms:
A. **Input.Text**: Captures text input from users. Properties include `placeholder` (hint text), `maxLength`, `isMultiline` (for multi-line text areas), and `value` (pre-filled content).
B. **Input.Number**: Captures numeric input with optional `min` and `max` constraints, and `placeholder` text.
C. **Input.Date**: Provides a date picker interface, capturing a date in YYYY-MM-DD format.
D. **Input.Time**: Provides a time picker, capturing time in HH:MM format.
E. **Input.Toggle**: Presents a binary choice (on/off, true/false, yes/no) with customizable labels for each state.
F. **Input.ChoiceSet**: Presents a set of options for the user to select from. Properties include `choices` (an array of choice objects with title and value), `style` (compact dropdown, expanded as radio buttons, or filtered search), and `isMultiSelect` (allow multiple selections).

<pre>All input elements have an <b>id</b> property (required) that uniquely identifies the input within the card, enabling the host application to capture and reference the submitted value.</pre>

### 4. Action and Control Elements
A. **ActionSet**: A container specifically for organizing action buttons. While actions can be placed in the root card's `actions` array, ActionSet allows actions to appear within the card body at a specific location.
B. **Media (version 1.1+)**: Embeds audio or video content with playback controls.


## Action Types and Interactions
Actions define what happens when users interact with buttons or elements within a card. Adaptive Cards support several action types:
### 1. Action.Submit
**Purpose**: Submits form data from input elements back to the host application.

When a user clicks a Submit button, the host application collects all input element values (identified by their id properties), packages them into a JSON object, and returns them to Copilot Studio. In Copilot Studio, these values are automatically captured into output variables that can be used in subsequent conversation steps.

<pre>
{
  "type": "Action.Submit",
  "title": "Submit",
  "data": {
    "action": "submit_form"
  }
}
</pre>

### 2. Action.OpenUrl
**Purpose**: Opens a specified URL in the user's default web browser.

This action is useful for linking to external resources, documentation, or web-based forms without requiring the user to leave the host application entirely.

<pre>
{
  "type": "Action.OpenUrl",
  "title": "Learn More",
  "url": "https://adaptivecards.io"
}
</pre>

### 3. Action.ShowCard
**Purpose**: Displays a nested card (another Adaptive Card) within the current card, typically triggered by a button click.

This enables progressive disclosure—showing additional options or details only when the user requests them, keeping the initial card clean and focused.

<pre>
{
  "type": "Action.ShowCard",
  "title": "More Options",
  "card": {
	"type": "AdaptiveCard",
	"body": [ ... ],
	"actions": [ ... ]
  }
}
</pre>

### 4. Action.Execute
**Purpose**: Similar to Action.Submit but designed for more complex, stateful interactions. Available in version 1.5+, it is the recommended action type for modern applications.

When triggered, Action.Execute can send input data to the host application and expect a response that may include updated card content or other actions.

<pre>
{
  "type": "Action.Execute",
  "title": "Execute Action",
  "data": {
	"command": "do_something"
  }
}
</pre>

### 5. Action.ToggleVisibility
**Purpose**: Toggles the visibility of specified elements within the card.

This action allows for dynamic content display without needing to reload or submit the card.

<pre>
{
  "type": "Action.ToggleVisibility",
  "title": "Show/Hide Details",
  "targetElements": [ "detailsContainer" ]
}
</pre>

### 6. Action.Downlaod
**Purpose**: Initiates a file download when the user clicks the button.

<pre>
{
  "type": "Action.Download",
  "title": "Download File",
  "url": "https://example.com/file.pdf"
}
</pre>

## Adaptive Card Versioning and Compatibility
Versioning is a critical consideration when designing Adaptive Cards, as different host applications and channels support different schema versions.

### Version Timeline and Support
The Adaptive Card schema has evolved from version 1.0 (released in 2016) through version 1.5 (current as of 2025). Each version introduces new elements, properties, and capabilities:
- **Version 1.0–1.1**: Core elements (TextBlock, Image, Container, Input.Text, Input.ChoiceSet, Input.Date, Input.Time, Input.Toggle, Input.Number, basic actions)
- **Version 1.2**: RichTextBlock, FactSet enhancements, Action.ShowCard
- **Version 1.3-1.4**: Additional input types, enhanced column properties, showCard improvements
- **Version 1.5**: Table element, Action.Execute, Action.Download, media enhancements

### Host Application Compatibility
Not all host applications support every version of the Adaptive Card schema. For example:
- **Microsoft Teams** (Web and Desktop): Typically supports versions 1.3 and later
- **Outlook** Supports versions 1.0–1.2 in Actionable Messages; 1.3+ via newer APIs
- Other platforms may have varying levels of support.
When designing cards for Copilot Studio, it is essential to verify the supported version for the target deployment channel to ensure that all features function as intended. If a card uses features from a newer version than the host supports, those features may be ignored or cause rendering issues.
- **Power Virtual Agents / Copilot Studio** historically supported version 1.2; newer releases support 1.3 and beyond

## The Adaptive Card Ecosystem
Beyond the core schema and element types, Adaptive Cards benefit from a rich ecosystem of tools and resources:

### 1. Adaptive Card Designer
The **Adaptive Card Designer** (available at `adaptivecards.microsoft.com/designer`) is a web-based visual tool for designing Adaptive Cards without writing JSON. The designer features:
- Drag-and-drop interface for adding and configuring elements
- Real-time preview of how the card will render in different host applications
- Export options to generate JSON code for use in applications like Copilot Studio
- Version selection to ensure compatibility with target hosts
- Templates for common card types

The designer is invaluable for makers without JSON expertise, though understanding the underlying JSON structure remains beneficial for advanced customization and troubleshooting.

### 2. Schema Explorer and Documentation
The **Adaptive Card Schema Explorer** (`adaptivecards.microsoft.com/`) is an interactive reference that documents every element type, property, and action, with examples and version information. This resource is essential for understanding the full capabilities of Adaptive Cards and checking version compatibility.

### 3. Sample Gallery and Community
Adaptive Cards maintains a sample gallery at `adaptivecards.microsoft.com/designer` with pre-built, production-ready card templates for common scenarios (approval workflows, expense reports, announcements, etc.). These samples serve as starting points and learning resources for teams building cards.

## Conclusion
Understanding the core concepts and architecture of Adaptive Cards is essential for effectively leveraging their capabilities in Copilot Studio. By mastering the JSON schema, element types, action mechanisms, and versioning considerations, makers can create rich, interactive experiences that enhance user engagement across multiple platforms. The Adaptive Card ecosystem, including design tools and documentation, further empowers makers to build sophisticated cards with ease.